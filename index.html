<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <title>Game Cast Receiver</title>
    <style>
        body {
            margin: 0;
            background: black;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            object-fit: cover; /* Fill TV, crop if needed */
            background: black;
        }
        #status {
            color: white;
            font-size: 2em;
            position: absolute;
            display: flex; 
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            background: black;
            text-align: center;
            padding: 20px;
        }
    </style>
    <script src="https://www.gstatic.com/cast/sdk/libs/caf_receiver/v3/cast_receiver_framework.js"></script>
</head>
<body>
    <div id="status">Waiting for connection...</div>
    <video id="remoteVideo" autoplay playsinline></video>

    <script>
        // ======== SETUP ========
        const pc = new RTCPeerConnection({
            iceServers: [
                { urls: "stun:stun.l.google.com:19302" },
                { urls: "stun:stun1.l.google.com:19302" }
            ]
        });

        const remoteVideo = document.getElementById("remoteVideo");
        const statusDiv = document.getElementById("status");
        const castContext = cast.framework.CastReceiverContext.getInstance();

        let lastFrameTime = 0;
        let frameCheckInterval;

        function updateStatus(message, color = "white") {
            statusDiv.innerText = message;
            statusDiv.style.color = color;
            console.log("Status:", message);
        }

        function sendToAndroid(type, data) {
            const message = { type, data };
            try {
                castContext.sendCustomMessage('urn:x-cast:webrtc.signaling', undefined, message);
            } catch (error) {
                console.error('Failed to send message to Android:', error);
            }
        }

        // ======== WEBRTC EVENTS ========
        pc.ontrack = event => {
            if (event.streams && event.streams[0] && event.streams[0].getVideoTracks().length > 0) {
                console.log("Received video stream from Android app");
                remoteVideo.srcObject = event.streams[0];
                statusDiv.style.display = 'none';
                updateStatus("Connected – Streaming video", "lime");

                const track = event.streams[0].getVideoTracks()[0];

                // Listen for track state changes
                track.onmute = () => updateStatus("Connected – Video muted (no frames)", "orange");
                track.onunmute = () => updateStatus("Connected – Video resumed", "yellow");
                track.onended = () => updateStatus("Connected – Video track ended", "red");

                // Frame arrival detection
                if ("requestVideoFrameCallback" in HTMLVideoElement.prototype) {
                    const checkFrame = () => {
                        lastFrameTime = performance.now();
                        updateStatus("Connected – Receiving frames", "lime");
                        remoteVideo.requestVideoFrameCallback(checkFrame);
                    };
                    remoteVideo.requestVideoFrameCallback(checkFrame);
                } else {
                    // Fallback for older firmware
                    remoteVideo.addEventListener("timeupdate", () => {
                        lastFrameTime = performance.now();
                        updateStatus("Connected – Receiving frames", "lime");
                    });
                }

                // Watchdog: detect if frames stop coming
                clearInterval(frameCheckInterval);
                frameCheckInterval = setInterval(() => {
                    if (performance.now() - lastFrameTime > 2000) {
                        updateStatus("Connected – No frames coming", "orange");
                    }
                }, 1000);

            } else {
                console.warn("Received track without video stream");
                updateStatus("Connected – No video track", "orange");
            }
        };

        pc.onicecandidate = event => {
            if (event.candidate) {
                console.log("Sending ICE candidate to Android app");
                sendToAndroid('ice-candidate', { candidate: event.candidate.toJSON() });
            }
        };

        pc.oniceconnectionstatechange = () => {
            const state = pc.iceConnectionState;
            console.log("ICE connection state:", state);
            switch(state) {
                case 'connecting':
                    updateStatus("Establishing connection...");
                    break;
                case 'connected':
                    updateStatus("Connected!", "yellow");
                    break;
                case 'disconnected':
                    updateStatus("Connection lost. Reconnecting...", "red");
                    statusDiv.style.display = 'flex';
                    break;
                case 'failed':
                    updateStatus("Connection failed. Please restart the app.", "red");
                    statusDiv.style.display = 'flex';
                    break;
                case 'closed':
                    updateStatus("Connection closed.", "red");
                    statusDiv.style.display = 'flex';
                    break;
            }
        };

        // ======== SIGNALING ========
        async function handleWebRTCSignaling(event) {
            const { type, data } = event.data;
            console.log("Received WebRTC message:", type);
            try {
                switch(type) {
                    case 'offer':
                        await handleOffer(data);
                        break;
                    case 'ice-candidate':
                        await handleIceCandidate(data);
                        break;
                    case 'connection-test':
                        sendToAndroid('connection-test-response', { status: 'ready' });
                        break;
                    default:
                        console.warn('Unknown message type:', type);
                }
            } catch (error) {
                console.error('Error handling WebRTC message:', error);
                updateStatus("Error processing connection data", "red");
            }
        }

        async function handleOffer(offerData) {
            console.log("Processing offer from Android app");
            updateStatus("Processing connection offer...");
            try {
                const offer = new RTCSessionDescription(offerData.offer);
                await pc.setRemoteDescription(offer);
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);
                sendToAndroid('answer', { answer: pc.localDescription.toJSON() });
                console.log("Answer sent to Android app");
            } catch (error) {
                console.error("Error creating answer:", error);
                updateStatus("Failed to establish connection", "red");
            }
        }

        async function handleIceCandidate(candidateData) {
            try {
                const candidate = new RTCIceCandidate(candidateData.candidate);
                await pc.addIceCandidate(candidate);
                console.log("Added ICE candidate from Android app");
            } catch (error) {
                console.error("Error adding ICE candidate:", error);
            }
        }

        // ======== CAST RECEIVER EVENTS ========
        castContext.addEventListener(cast.framework.system.EventType.READY, () => {
            console.log("Cast receiver is ready for WebRTC connections");
            updateStatus("Ready for connection from Android app");
        });

        castContext.addCustomMessageListener('urn:x-cast:webrtc.signaling', handleWebRTCSignaling);

        castContext.addEventListener(cast.framework.system.EventType.SENDER_CONNECTED, (event) => {
            console.log("Android app connected:", event.senderId);
            updateStatus("Android app connected. Initializing...");
        });

        castContext.addEventListener(cast.framework.system.EventType.SENDER_DISCONNECTED, (event) => {
            console.log("Android app disconnected:", event.senderId);
            updateStatus("Android app disconnected", "red");
            if (pc.connectionState !== 'closed') {
                pc.close();
            }
            remoteVideo.srcObject = null;
            statusDiv.style.display = 'flex';
        });

        castContext.start();

        document.addEventListener('visibilitychange', () => {
            if (document.hidden && pc.connectionState !== 'closed') {
                console.log("Page hidden, maintaining connection");
            }
        });
    </script>
</body>
</html>

